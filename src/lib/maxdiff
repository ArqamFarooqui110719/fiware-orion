apiTypesV2/Subscription.h:53:  long long                maxFailsLimit;
apiTypesV2/Subscription.h:69:    maxFailsLimit(0),
apiTypesV2/Subscription.h:120:  long long     maxFailsLimit;
apiTypesV2/SubscriptionUpdate.h:46:  bool  maxFailsLimitProvided;
apiTypesV2/SubscriptionUpdate.h:58:    maxFailsLimitProvided(false),
apiTypesV2/Subscription.cpp:100://  if (this->maxFailsLimit > 0)
apiTypesV2/Subscription.cpp:102://    jh.addNumber("maxFailsLimit", this->maxFailsLimit);
apiTypesV2/Subscription.cpp:127:  if ((this->failsCounter> 0) && (this->maxFailsLimit> 0))
apiTypesV2/Subscription.cpp:194:  if (this->maxFailsLimit > 0)
apiTypesV2/Subscription.cpp:196:    jh.addNumber("maxFailsLimit", this->maxFailsLimit);
cache/subCache.cpp:740:  int64_t                            maxFailsLimit,
cache/subCache.cpp:775:  cSubP->maxFailsLimit         = maxFailsLimit;
cache/subCache.h:102:  int64_t                     maxFailsLimit;
cache/subCache.h:198:  int64_t                            maxFailsLimit,
jsonParseV2/parseSubscription.cpp:244:  //MaxFailsLimit
jsonParseV2/parseSubscription.cpp:245:  Opt<int64_t> maxFailsLimitOpt = getInt64Opt(document, "maxFailsLimit");
jsonParseV2/parseSubscription.cpp:246:  if (!maxFailsLimitOpt.ok())
jsonParseV2/parseSubscription.cpp:248:    return badInput(ciP, maxFailsLimitOpt.error);
jsonParseV2/parseSubscription.cpp:250:  else if (maxFailsLimitOpt.given)
jsonParseV2/parseSubscription.cpp:252:    subsP->maxFailsLimitProvided = true;
jsonParseV2/parseSubscription.cpp:253:    subsP->maxFailsLimit = maxFailsLimitOpt.value;
jsonParseV2/parseSubscription.cpp:255:  else if (!update)  // maxFailsLimit was not set and it is not update
jsonParseV2/parseSubscription.cpp:257:    subsP->maxFailsLimit = 0;  // Default value if not provided at creation => no maxFailsLimit
mongoBackend/dbConstants.h:97:#define CSUB_MAXFAILSLIMIT           "maxFailsLimit"
mongoBackend/TriggeredSubscription.cpp:43:  long long                _maxFailsLimit,
mongoBackend/TriggeredSubscription.cpp:54:  maxFailsLimit(_maxFailsLimit),
mongoBackend/TriggeredSubscription.cpp:84:  maxFailsLimit(-1),
mongoBackend/MongoCommonSubscription.h:71:* setMaxFailsLimit -
mongoBackend/MongoCommonSubscription.h:73:extern void setMaxFailsLimit(const ngsiv2::Subscription& sub, orion::BSONObjBuilder* b);
mongoBackend/mongoSubCache.cpp:110:  cSubP->maxFailsLimit            = sub.hasField(CSUB_MAXFAILSLIMIT)?       getIntOrLongFieldAsLongF(sub, CSUB_MAXFAILSLIMIT)       : -1;
mongoBackend/mongoSubCache.cpp:364:  cSubP->maxFailsLimit            = sub.hasField(CSUB_MAXFAILSLIMIT)? getIntOrLongFieldAsLongF(sub, CSUB_MAXFAILSLIMIT) : -1;
mongoBackend/TriggeredSubscription.h:56:  long long                 maxFailsLimit;
mongoBackend/TriggeredSubscription.h:77:                        long long                _maxFailsLimit,
mongoBackend/mongoGetSubscriptions.cpp:165:  subP->maxFailsLimit   = r.hasField(CSUB_MAXFAILSLIMIT)?    getIntOrLongFieldAsLongF(r, CSUB_MAXFAILSLIMIT)    : -1;
mongoBackend/mongoGetSubscriptions.cpp:191:    if (cSubP->maxFailsLimit > subP->notification.maxFailsLimit)
mongoBackend/mongoGetSubscriptions.cpp:193:      subP->notification.maxFailsLimit = cSubP->maxFailsLimit;
mongoBackend/mongoUpdateSubscription.cpp:167: * * setMaxFailsLimit -
mongoBackend/mongoUpdateSubscription.cpp:169:static void setMaxFailsLimit(const SubscriptionUpdate& subUp, const orion::BSONObj& subOrig, orion::BSONObjBuilder* b)
mongoBackend/mongoUpdateSubscription.cpp:171:  if (subUp.maxFailsLimitProvided)
mongoBackend/mongoUpdateSubscription.cpp:173:    setMaxFailsLimit(subUp, b);
mongoBackend/mongoUpdateSubscription.cpp:177:    if (subOrig.hasField(CSUB_MAXFAILSLIMIT))
mongoBackend/mongoUpdateSubscription.cpp:179:      long long maxFailsLimit = getIntOrLongFieldAsLongF(subOrig, CSUB_MAXFAILSLIMIT);
mongoBackend/mongoUpdateSubscription.cpp:181:      b->append(CSUB_MAXFAILSLIMIT, maxFailsLimit);
mongoBackend/mongoUpdateSubscription.cpp:182:      LM_T(LmtMongo, ("Subscription maxFailsLimit: %lu", maxFailsLimit));
mongoBackend/mongoUpdateSubscription.cpp:856:  setMaxFailsLimit(subUp, subOrig, &b);
mongoBackend/mongoCreateSubscription.cpp:99:                     sub.maxFailsLimit,
mongoBackend/mongoCreateSubscription.cpp:151:  setMaxFailsLimit(sub, &b);
mongoBackend/MongoCommonUpdate.cpp:1092:                                                           cSubP->maxFailsLimit,
mongoBackend/MongoCommonUpdate.cpp:1512:      long long         maxFailsLimit         = sub.hasField(CSUB_MAXFAILSLIMIT)?       getIntOrLongFieldAsLongF(sub, CSUB_MAXFAILSLIMIT)       : -1;
mongoBackend/MongoCommonUpdate.cpp:1533:          maxFailsLimit,
mongoBackend/MongoCommonUpdate.cpp:1690:  long long                        maxFailsLimit,
mongoBackend/MongoCommonUpdate.cpp:1755:                                          maxFailsLimit,
mongoBackend/MongoCommonUpdate.cpp:1896:                                                                tSubP->maxFailsLimit,
mongoBackend/MongoCommonSubscription.cpp:171:* setMaxfailsLimit -
mongoBackend/MongoCommonSubscription.cpp:173:void setMaxFailsLimit(const Subscription& sub, orion::BSONObjBuilder* b)
mongoBackend/MongoCommonSubscription.cpp:175:  b->append(CSUB_MAXFAILSLIMIT, sub.maxFailsLimit);
mongoBackend/MongoCommonSubscription.cpp:176:  LM_T(LmtMongo, ("Subscription maxFailsLimit: %lu", sub.maxFailsLimit));
ngsi/CMakeLists.txt:58:    MaxFailsLimit.cpp
ngsi/CMakeLists.txt:94:    MaxFailsLimit.h
ngsi/MaxFailsLimit.cpp:33:#include "ngsi/MaxFailsLimit.h"
ngsi/MaxFailsLimit.cpp:40:int64_t MaxFailsLimit::parse(void)
ngsi/MaxFailsLimit.cpp:50:* MaxFailsLimit::check -
ngsi/MaxFailsLimit.cpp:52:std::string MaxFailsLimit::check(void)
ngsi/MaxFailsLimit.cpp:64:    return "syntax error in maxFailsLimit string";
ngsi/MaxFailsLimit.cpp:74:* MaxFailsLimit::isEmpty -
ngsi/MaxFailsLimit.cpp:76:bool MaxFailsLimit::isEmpty(void)
ngsi/MaxFailsLimit.cpp:85:* MaxFailsLimit::set -
ngsi/MaxFailsLimit.cpp:87:void MaxFailsLimit::set(const std::string& value)
ngsi/MaxFailsLimit.cpp:96:* MaxFailsLimit::get -
ngsi/MaxFailsLimit.cpp:98:const std::string MaxFailsLimit::get(void)
ngsi/MaxFailsLimit.cpp:107:* MaxFailsLimit::toJsonV1 -
ngsi/MaxFailsLimit.cpp:109:std::string MaxFailsLimit::toJsonV1(bool comma)
ngsi/MaxFailsLimit.cpp:116:  return valueTag("maxFailsLimit", string, comma);
ngsi/MaxFailsLimit.h:1:#ifndef SRC_LIB_NGSI_MAXFAILSLIMIT_H_
ngsi/MaxFailsLimit.h:2:#define SRC_LIB_NGSI_MAXFAILSLIMIT_H_
ngsi/MaxFailsLimit.h:37:* MaxFailsLimit - 
ngsi/MaxFailsLimit.h:39:typedef struct MaxFailsLimit
ngsi/MaxFailsLimit.h:44:  MaxFailsLimit(): seconds(-1) {}
ngsi/MaxFailsLimit.h:54:} MaxFailsLimit;
ngsi/MaxFailsLimit.h:56:#endif  // SRC_LIB_NGSI_MAXFAILSLIMIT_H_
ngsi10/SubscribeContextRequest.cpp:61:      ((res = maxFailsLimit.check())                                                    != "OK"))
ngsi10/SubscribeContextRequest.h:37:#include "ngsi/MaxFailsLimit.h"
ngsi10/SubscribeContextRequest.h:58:  MaxFailsLimit          maxFailsLimit;          // Optional
ngsi10/UpdateContextSubscriptionRequest.cpp:127:  subUp->maxFailsLimitProvided   = !maxFailsLimit.isEmpty();
ngsiNotify/Notifier.cpp:70:    long long                        maxFailsLimit,
ngsiNotify/Notifier.cpp:85:                                                                          maxFailsLimit,
ngsiNotify/Notifier.cpp:125:    long long                            maxFailsLimit,
ngsiNotify/Notifier.cpp:313:    params->maxFailsLimit    = maxFailsLimit;
ngsiNotify/Notifier.cpp:347:  long long                        maxFailsLimit,
ngsiNotify/Notifier.cpp:389:                                     maxFailsLimit,
ngsiNotify/Notifier.cpp:455:    params->maxFailsLimit    = maxFailsLimit;
ngsiNotify/senderThread.h:57:  long long                          maxFailsLimit;
ngsiNotify/QueueWorkers.cpp:48:#include "ngsi/MaxFailsLimit.h"
ngsiNotify/QueueWorkers.cpp:168:      LM_T(LmtNotifier, ("worker sending to: host='%s', port=%d, verb=%s, tenant='%s', maxFailsLimit='%lu', failsCounter='%lu', service-path: '%s', xauthToken: '%s', path='%s', content-type: %s",
ngsiNotify/QueueWorkers.cpp:173:                         params->maxFailsLimit,
ngsiNotify/QueueWorkers.cpp:206:                                     params->maxFailsLimit,
ngsiNotify/QueueWorkers.cpp:242:          if ((cSubP->failsCounter) > (cSubP->maxFailsLimit))
ngsiNotify/QueueNotifier.cpp:130:  long long                        maxFailsLimit,
ngsiNotify/QueueNotifier.cpp:144: 									  maxFailsLimit,
ngsiNotify/QueueNotifier.h:63:                                long long                        maxFailsLimit,
ngsiNotify/Notifier.h:51:                                        long long                        maxFailsLimit,
ngsiNotify/Notifier.h:65:                                                             long long                        maxFailsLimit,
ngsiNotify/senderThread.cpp:43:#include "ngsi/MaxFailsLimit.h"
ngsiNotify/senderThread.cpp:63:   // limit = params->maxFailsLimit;
ngsiNotify/senderThread.cpp:67:    LM_T(LmtNotifier, ("sending to: host='%s', port=%d, verb=%s, tenant='%s', maxFailsLimit='%lu', failsCounter='%lu', service-path: '%s', xauthToken: '%s', path='%s', content-type: %s",
ngsiNotify/senderThread.cpp:72:                       params->maxFailsLimit,
ngsiNotify/senderThread.cpp:81:  //  LM_T(LmtNotificationRequestPayload , ("notification request payload: %s", params->maxFailsLimit));
ngsiNotify/senderThread.cpp:95:                          params->maxFailsLimit,
ngsiNotify/senderThread.cpp:108:     // LM_T(LmtNotificationResponsePayload, ("notification response: %s", params->maxFailsLimit));
ngsiNotify/senderThread.cpp:125:       /* if ((failsCounter) > (params->maxFailsLimit))
rest/httpRequestSend.cpp:250:   long long                                  maxFailsLimit,
rest/httpRequestSend.cpp:632:   long long                                  maxFailsLimit,
rest/httpRequestSend.cpp:675:                                     maxFailsLimit, 
rest/httpRequestSend.h:66:  long long                                  maxFailsLimit,
rest/httpRequestSend.h:97:  long long                                  maxFailsLimit,
serviceRoutines/postUpdateContext.cpp:150:  long long       maxFailsLimit = -1;
serviceRoutines/postUpdateContext.cpp:219:                      maxFailsLimit,
serviceRoutines/postQueryContext.cpp:145:  long long       maxFailsLimit = -1;
serviceRoutines/postQueryContext.cpp:281:                      maxFailsLimit,
